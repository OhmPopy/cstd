#include <signal.h>
#include "cfile.h"
#include "net.h"
//#include "getopt.inl"
#include "httpd.inl"


// ** This is a static page of HTML. It is loaded into the content
// ** tree using httpdAddStaticContent( ).

#define test1_html "<HTML><BODY>This is just a test</BODY>"
#define ember_code1 "printf(\"This is from ember in process %d\n\",getpid());"
#define ember_code "load \"/usr/local/nk/www/content.lib\"; dispatchWebPage(\"/index.html\");"
// Below are 2 dynamic pages, each generated by a C function. The first
// is a simple page that offers a little dynamic info (the process ID)
// and the setups up a test link and a simple form.
// 
// The second page processes the form. As you can see, you can access
// the form data from within your C code by accessing the symbol table
// using httpdGetVariableByName() (and other similar functions). You
// can also include variables in the string passed to httpdOutput( ) and
// they will be expanded automatically.

char* cstrstr(const char* s, int l, const char* s1, int l1, int ignore_case) {
  int index = cstr_find(s, l, s1, l1, 0, ignore_case);
  return index>=0 ? ((char*)s+index) : NULL;
}

#include "img/imgio.inl"
#include "face/face_recog_mojin.inl"
#include "parser/cjson.inl"


typedef struct meninfo_t {
  uint rec_count; // 识别次数
  char username[32];
} meninfo_t;

int get_mojing_info_json(const char* info, meninfo_t* out) {
  cJSON* root, *item;
  cJSON* json;
  int ok_count=0;
  json = cJSON_Parse(info);
  int id=-1;
  out->username[0]=0;
  if (json) {
    if (item = cJSON_GetObjectItem(json, "id")) {
      if (item->valuestring) {
        id = atoi(item->valuestring);
      } else {
        id = item->valueint;
      }
      ++ok_count;
    }
    if (item = cJSON_GetObjectItem(json, "username")) {
      if (item->valuestring) {
        strncpy(out->username, item->valuestring, countof(out->username));
        ++ok_count;
      }
    }
  }
  cJSON_Delete(json);
  return id;
}

int getim_from_multipart(httpReq* req, img_t* im, str_t* bfs) {
  int nimgs=0;
  int i, j, nbfs=0;
  if (0==strncasecmp2(req->contentType, "multipart/form-data")) {
    char* cp = NULL, *cp1, *cp2, *cp3, *cp4, *cpend;
    const char* boundary = NULL;
    {
      cp = req->contentType;
      //cp = "multipart/form-data; boundry=---------------------------7db1851cd1158";
      cp1 = strchr(cp, ';');
      if (cp1) {
        cp1 += 1;
        for (; *cp1==' '; ++cp1);
        if (strncasecmp(cp1, "boundary", 8) == 0) {
          cp2 = strchr(cp1, '=');
          if (cp2) {
            boundary = cp2+1;
          }
        }
      }
    }
    //boundary = "-----------------------------7db1851cd1158";
    int boundarylen = boundary ? strlen(boundary) : 0;
    //str_t name[1] = {0};
    //str_t filename[1] = {0};
    int nimage = 0;
    cp = req->content;
    cpend = req->content + req->contentLength;
    int pos=0;
    char buf[256];
    const char* timenow = _strtime2();
    _snprintf(buf, 256, "content_%s.txt", timenow);
    savefile(buf, req->content, req->contentLength);
    if (boundarylen>0) {
      for (; (pos = cstr_find(req->content, req->contentLength, boundary, boundarylen, pos, 1))>=0; ) {
        pos+=boundarylen+2;
        bfs[nbfs++].s = req->content+pos;
      }
    } else {
      bfs[0].s = req->content;
      bfs[0].l = req->contentLength;
      nbfs = 1;
    }
    for (i=nbfs-1; i>=0; --i) {
      bfs[i].l = cpend-bfs[i].s;
      cpend = bfs[i].s-boundarylen-2;
    }
    j=0;
    for (i=0; i<nbfs; ++i) {
      if (bfs[i].l>10) {
        bfs[j++] = bfs[i];
      }
    }
    nbfs = j;
    cp = req->content;
    const char* info = NULL;
    int infolen=0;
    for (i=0; i<nbfs; ++i) {
      enum CONTENT_TYPE {CONTENT_NUL, CONTENT_IMAGE, CONTENT_TEXT};
      CONTENT_TYPE content_type=CONTENT_NUL;
      char* end = bfs[i].s+bfs[i].l;
      char* name = NULL;
      cp1 = bfs[i].s;
      for (;cp1;) {
        if (0==strncasecmp2(cp1, "Content-Disposition: ")) {
          cp2 = cp1+21;
          printf("%s\n", cp2);
          for (; cp2 = strchr(cp2, ';');) {
            cp2+=1;
            for (; *cp2==' '; ++cp2);
            if (0==strncasecmp2(cp2, "name=")) {
              name = cp2+5;
            } else if (0==strncasecmp2(cp2, "filename=")) {
            }
          }
        } else if (0==strncasecmp2(cp1, "Content-Type: ")) {
          cp2 = cp1+14;
          if (0==strncasecmp2(cp2, "image")) {
            ++nimage;
            content_type = CONTENT_IMAGE;
          }
          //printf("%s\n", cp2);
          //cp1 = strstr(cp1, "\r\n");
          //if (cp1) {cp1+=2;}
        } else if (CONTENT_IMAGE==content_type) {
          while (cp1<end && cp1[0]=='\r' && cp1[1]=='\n') {
            cp1+=2;
          }
          bfs[i].s = cp1;
          bfs[i].l = end-cp1;
          _snprintf(buf, 256, "aaa_%s_%d.jpg", timenow, i);
          str_save(buf, bfs+i);
          if (imload_mem(cp1, end-cp1, 3, im+nimgs)) {
            //imshow_(im+i);WaitKey(-1);
            ++nimgs;
            break;
          }
        }
        if (name && 0==strncasecmp2(name, "\"info\"")) {
          char* cp2 = strstr(name+6, "\r\n");
          while (cp2<end && cp2[0]=='\r' && cp2[1]=='\n') {
            cp2+=2;
          }
          info = cp2;
          infolen = end-cp2;
        }
        cp1 = strstr(cp1, "\r\n");
        if (cp1) {cp1+=2;}
      }
    }
  }
  return nimgs;
}

#include "parser/cjson.inl"

int getim_from_body_base64(const char* str, img_t* im, str_t* bfs) {
  cJSON *pJsRoot = cJSON_Parse(str), *pJsCode, *pJsArr, *pJsArr2;
  int ErrNO = -1;
  int i, narr = 0;
  if (pJsRoot) {
    if ((pJsCode = cJSON_GetObjectItem(pJsRoot, "face_data"))) {
      narr = cJSON_GetArraySize(pJsCode);
      for (i=0; i<narr; ++i) {
        if (pJsArr = cJSON_GetArrayItem(pJsCode, i)) {
          if (pJsArr2 = cJSON_GetArrayItem(pJsArr, 9)) {
            const char* str = pJsArr2->valuestring;
            int len = strlen(str);
            str_setsize(bfs+i, len);
            bfs[i].l = base64_decode(str, len, bfs[i].s, len);
            //img_t im[1] = {0};
            str_save("D:\\asdf.jpg", bfs);
            imload_mem(bfs[i].s, bfs[i].l, 3, im+i);
            imshow_(im);WaitKey(-1);
          }
        }
      }
    }
    cJSON_Delete(pJsRoot);
  }
  return narr;
}
int test_parse_content() {
  str_t str[1] = {0};
  str_load("content_20180322150147.txt", str);
  img_t im[100] = {0};
  str_t bfs[100] = {0};
  if (str->s && str->l>0) {
    getim_from_body_base64(str->s, im, bfs);
  }
  imfrees(im, 100);
  str_frees(bfs, 100);
  str_free(str);
  return 0;
}

int getim_from_multipart1(httpReq* req, img_t* im, str_t* bfs) {
  str_t str[1] = {0};
  str_load("content.txt", str);
  req->content = str->s;
  req->contentLength = str->l;
  if (req->content && req->contentLength>0) {
    return getim_from_body_base64(req->content, im, bfs);
  }
  return 0;
}

void index_html(httpd* s)
{
#if 0
  httpdPrintf(s, "Welcome to the httpd server running in process number %d<P>\n", sys_getpid());
  httpdPrintf(s, "Click <A HREF=/test1.html>here</A> to view a test page<P>\n");
  httpdPrintf(s, "Click <A HREF=/login.html>here</A> to authenticate<P>\n");
  httpdPrintf(s, "Or <A HREF=/wildcard/foo>here</A> for a test wildcard page<P>\n");
  httpdPrintf(s, "<P><FORM ACTION=test2.html METHOD=POST>\n");
  httpdPrintf(s, "Enter your name <INPUT NAME=name SIZE=10>\n");
  httpdPrintf(s, "<INPUT TYPE=SUBMIT VALUE=Click!><P></FORM>\n");
#endif
#if 1
  httpReq* req = &s->request;
#if 0
  str_t bf[1] = {0};
  str_load("content_20171019160813.txt", bf);
  req->content = bf->s;
  req->contentLength = bf->l;
#endif
  char buf[256];
  enum {maxnum = 100};
  img_t im[maxnum] = {0};
  str_t bfs[maxnum] = {0};
  const char* timenow = _strtime2();
  //_snprintf(buf, 256, "content.txt", timenow);
  //savefile(buf, req->content, req->contentLength);
  int i, j;
  
  int nimgs = getim_from_multipart1(req, im, bfs);
  if (1) {
    static int inited=0;
    static buf_t meninfo_bf[1] = {0};
    if (!inited) {
      inited = 1;
      buf_load("meninfo.dat", meninfo_bf);
    }
    
    meninfo_t* meninfo = (meninfo_t*)meninfo_bf->data;
    int mennum = meninfo_bf->len/sizeof(meninfo_t);
    for (j=0; j<nimgs; ++j) {
      int id=-1, isnew=0;
      int ret = face_recog_mojin(im+j, 1, &id, &isnew);
      const char* retstr = face_recog_falg_to_str(ret);
      if (!retstr) {retstr = "";}
      printf("id=%d\n", id);
      if (id>=0) {
        if (id>=mennum) {
          mennum = id+1;
          bfsetsize(meninfo_bf, mennum*sizeof(meninfo_t));
          meninfo = (meninfo_t*)meninfo_bf->data;
          memset(meninfo+id, 0, (mennum-id)*sizeof(meninfo_t));
          meninfo[id].rec_count = 1;
        } else {
          meninfo[id].rec_count++;
        }
        buf_save("meninfo.dat", meninfo_bf);
        int role_id = id%20+1;
        httpdPrintf(s, "{\"result\":\"%s\",\"id\":\"%d\",\"isnew\":\"%s\",\"role_id\":\"%d\",\"username\":\"%s\",\"rec_count\":\"%d\" }\n", retstr, id, isnew?"true":"false", role_id, meninfo[id].username, meninfo[id].rec_count);
      } else {
        httpdPrintf(s, "{\"result\":\"%s\",\"id\":%d}\n", retstr, id);
      }
      _snprintf(buf, 256, "feat/%d", id);
      sys_mkdir(buf);
      int nbfs = nimgs;
      for (i=0; i<nbfs; ++i) {
        _snprintf(buf, 256, "feat/%d/%s_%d.jpg", id, timenow, i);
        //imwrite(buf, im+i+1);
        str_save(buf, bfs+i);
      }
    }
    str_frees(bfs, maxnum);
    imfrees2(im);  
  }
#endif
  return;
}
void test2_html(httpd* s)
{
  httpVar* variable;
  // Grab the symbol table entry to see if the variable exists
  variable = httpdGetVariableByName(s, "name");
  if (variable == NULL) {
    httpdPrintf(s, "Missing form data!");
    return;
  }
  // Use httpdOutput() rather than httpdPrintf() so that the variable embedded in the text is expanded automatically
  //httpdOutput(s, "Hello $name 大傻逼");
  httpdPrintf(s, "<P>Hello %s 大傻逼!</P>", variable->value);
}
void test3_html(httpd* s)
{
  char* path;
  path = httpdRequestPath(s);
  httpdOutput(s, "Wilcard dynamic request received<P>");
  httpdPrintf(s, "The requested path was %s<P>", path);
}
void login_html(httpd* s)
{
  if (httpdAuthenticate(s, "LibHTTPD Test") == 0) {
    return;
  }
  httpdPrintf(s, "Your username is '%s'<P>\n", s->request.authUser);
  httpdPrintf(s, "Your password is '%s'<P>\n", s->request.authPassword);
  httpdOutput(s, "Click <A HREF=login2.html>here</A> to force reauthentication");
  httpdOutput(s, ". Use a username = test password = 123");
}
void login2_html(httpd* s)
{
  if (httpdAuthenticate(s, "LibHTTPD Test") == 0) {
    httpdOutput(s, "Authentication failure(1).");
    return;
  }
  if (strcmp(s->request.authUser, "test") != 0 ||
      strcmp(s->request.authPassword, "123") != 0) {
    httpdForceAuthenticate(s, "LibHTTPD Test");
    httpdOutput(s, "Authentication failure (2).");
    return;
  }
  httpdOutput(s, "Your login was accepted.");
}
void myError404Handler(httpd* s, int error)
{
  httpdOutput(s, "Whoa there. You hit a page that doesn't exist! <P><BR><BR>\n");
  httpdOutput(s, "Or in other words : <B>Error 404</B>\n\n");
}
int test_httpd_face_recog_mojin(int argc, char* argv[])
{
  //test_parse_content();
  //CPCODE;
  //sys_mkdir("C:/code/testc/root");
  //sys_chdir("C:/code/testc/root");
  httpd* s = NULL;
  char* host = NULL;
  int port, errFlag, result;
  extern char* optarg;
  extern int optind, opterr, optopt;
  timeval_t timeout[1];
  errFlag = 0;
#if 0
  int c;
  while ((c = getopt(argc, argv, "h:p:")) != -1) {
    switch (c) {
    case 'h':
      host = optarg;
      break;
    case 'p':
      port = atoi(optarg);
      break;
    default:
      errFlag++;
    }
  }
  if (errFlag) {
    fprintf(stderr, "usage: [-h <host IP>] [ -p <port >]\n");
    fprintf(stderr, "\nLibHTTPD version %s\n\n", LIBHTTPD_VERSION);
    exit(1);
  }
#else
  host = NULL;
  //host = 10.1.100.223
  port = 80;
  //host = "192.168.1.3";
  if (argc>1) {
    //port = atoi(argv[1]);
  }
#endif
  /*
  ** Ensure that PIPE signals are either handled or ignored.
  ** If a client connection breaks while the server is using
  ** it then the application will be sent a SIGPIPE. If you
  ** don't handle it then it'll terminate your application.
  */
  //signal(SIGPIPE, SIG_IGN);
  /*
  ** Create a server and setup our logging
  */
  s = httpdCreate(host, port);
  if (s == NULL) {
    perror("Can't create server");
    exit(1);
  }
  httpdSetAccessLog(s, stdout);
  httpdSetErrorLog(s, stdout);
  // We are fussy and don't want the default Error 404 page
  httpdSetErrorFunction(s, 404, myError404Handler);
  // Setup some content for the server
  httpdAddCContent(s, "/", "index.html", HTTP_TRUE, NULL, index_html);
  httpdAddCContent(s, "/", "test2.html", HTTP_FALSE, NULL, test2_html);
  httpdAddCContent(s, "/", "login.html", HTTP_FALSE, NULL, login_html);
  httpdAddCContent(s, "/", "login2.html", HTTP_FALSE, NULL, login2_html);
  httpdAddCWildcardContent(s, "/wildcard", NULL, test3_html);
  httpdAddStaticContent(s, "/", "test1.html", HTTP_FALSE, NULL, test1_html);
  httpdAddEmberContect(s, "/", "ember.html", HTTP_FALSE, NULL, ember_code);
  // Go into our service loop
  printf("server start..... \n");
  while (1 == 1) {
    // Linux modifies the timouet value during the
    // select call so we must set it everyt ime. Most
    // other UNIX implementations do not modify timeout
    // but it doesn't hurt to set it each time anyway
    result = httpdGetConnection(s, 5000);
    if (result == 0) {
      printf("Timeout ... \n");
      continue;
    }
    if (result < 0) {
      printf("Error ... \n");
      continue;
    }
    printf("%s connect\n", s->clientAddr);
    if (httpdReadRequest(s) < 0) {
      httpdEndRequest(s);
      continue;
    }
    httpdProcessRequest(s);
    httpdEndRequest(s);
  }
  return 0;
}
