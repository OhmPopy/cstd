1.本程序实现了如下功能：
（1）检验正则表达式是否正确。
（2）将正则表达式转化为后缀表达式（中间有一步是为表达是添加连接字符用"^"表示）。
（3）将后缀表达式转化为NFA。
（4）将NFA转化为DFA。
（5）将DFA最小化。
（6）检测输入字符串是否可接受。
2.大体算法说明：
（1）正则表达式转化为后缀表达式
     转后缀表达式是参考以前做的计算器的算法，用栈来保存运算符，再根据运算符优先级  进 行压栈、出栈，而操作数是直接作为后缀式输出。
（2）后缀表达式转化为NFA：
     利用一个栈保存操作字符，当读入的是非运算符就压栈，如果遇到运算符就从栈中弹出  字 符进行运算，*、|、连接符的运算规则自己写，运算结束后再将结果压栈，直至运算结束。
（3）将NFA转化为DFA：
     这步是将NFA中的$边去掉，用了两个算法，一个是Find_NULL_Closure()找到当前起点输入$  后到的集合，一个是 Move（T,S）找到输入某个字符后到的集合，期间用一个队列保存所有目标 集合，如果这个队列中没有得到的目标状态，就把它放进队列，然后不断进行队列的弹出，知道 遍历完所有NFA边。次步结束后得到了DFA边，终态和非终态。
（4）将DFA最小化：
     最小化是合并相同的状态，首先将非终态和终态划分为两个集合，利用队列保存这些状态， 然后遍历队列，从队列取出元素后，看看这个元素能不能进行区分，是否可区分是看当一个起始 状态输入某字符后到达的集合是否一样，如果有不一样的，说明可分，如果第一次输入不能区分 ，就输入下一个字符，以此类推，如果都不能区分，就说明是相同的状态。如果可区分的话，就  把区分后的状态放进队列。如果某集合的状态相同，就从中取出一个代表元素，其他状态的起点  和终点边都引到代表元素上。同时还要去掉一样的边。此步得到了最小化DFA边。
3.存储结构
   主要用到了容器，因为它在不知道元素多少的情况下添加元素很方便，并且查找和扩充很方便。
队列是遍历边的时候保存临时状态集合，栈是在正则表达式到NFA，以及计算NFA是保存运算负和操作数。
自定义数据结构：
自动机的边
typedef struct EDGE                   
{
    int start;                            // 起点
    char input_expr;                      // 输入字符
    int end;                              // 终点
}EDGE;
构造的NFA
typedef struct NFA            
{
    int start;                            // 起点                
    int end;                              // 终点
}NFA;
