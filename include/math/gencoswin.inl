// 几种常见窗函数
// 矩形窗 Rectangle
// 矩形窗使用最多，习惯上不加窗就是使信号通过了矩形窗。这种窗的优点是主瓣比较集中，缺点是旁瓣较高，并有负旁瓣，导致变换中带进了高频干扰和泄漏，甚至出现负谱现象。频率识别精度最高，幅值识别精度最低，所以矩形窗不是一个理想的窗。
// 如果仅要求精确读出主瓣频率，而不考虑幅值精度，则可选用矩形窗，例如测量物体的自振频率等，也可以用在阶次分析中。
// 汉宁窗 Hanning
// 又称升余弦窗。主瓣加宽并降低，旁瓣则显著减小，从减小泄漏观点出发，汉宁窗优于矩形窗．但汉宁窗主瓣加宽，相当于分析带宽加宽，频率分辨力下降。它与矩形窗相比，泄漏、波动都减小了,并且选择性也提高。
// 是很有用的窗函数。如果测试信号有多个频率分量，频谱表现的十分复杂，且测试的目的更多关注频率点而非能量的大小，需要选择汉宁窗。如果被测信号是随机或者未知的，选择汉宁窗。
// 海明窗（汉明窗） Hamming
// 与汉宁窗都是余弦窗，又称改进的升余弦窗，只是加权系数不同，使旁瓣达到更小。但其旁瓣衰减速度比汉宁窗衰减速度慢。
// 与汉明窗类似，也是很有用的窗函数。
// 平顶窗 Flap Top
// 平顶窗在频域时的表现就象它的名称一样有非常小的通带波动。
// 由于在幅度上有较小的误差，所以这个窗可以用在校准上。
// 凯塞窗 Kaiser
// 定义了一组可调的由零阶贝塞尔Bessel 函数构成的窗函数，通过调整参数β可以在主瓣宽度和旁瓣衰减之间自由选择它们的比重。对于某一长度的Kaiser 窗，给定β，则旁瓣高度也就固定了。
// 布莱克曼窗 Blackman
// 二阶升余弦窗，主瓣宽，旁瓣比较低，但等效噪声带宽比汉宁窗要大一点，波动却小一点。频率识别精度最低，但幅值识别精度最高，有更好的选择性。
// 常用来检测两个频率相近幅度不同的信号。
// 高斯窗 Gaussian
// 是一种指数窗。主瓣较宽，故而频率分辨力低；无负的旁瓣，第一旁瓣衰减达一55dB。常被用来截短一些非周期信号，如指数衰减信号等。
// 对于随时间按指数衰减的函数，可采用指数窗来提高信噪比。
// 三角窗（费杰窗） Fejer
// 是幂窗的一次方形式。与矩形窗比较，主瓣宽约等于矩形窗的两倍，但旁瓣小，而且无负旁瓣。
// 如果分析窄带信号，且有较强的干扰噪声，则应选用旁瓣幅度小的窗函数，如汉宁窗、三角窗等；
// 切比雪夫窗 Chebyshev
// 在给定旁瓣高度下，Chebyshev窗的主瓣宽度最小，具有等波动性，也就是说，其所有的旁瓣都具有相等的高度。
enum {
  cw_hann,
  cw_hamming,
  cw_blackman,
  cw_flattopwin,
};
int calc_window(int m, int n, int window, double* w)
{
  double a0, a1, a2, a3, a4;
  int i;
  switch (window) {
  case cw_hann:
    //% Hann window
    //%    w = 0.5 * (1 - cos(2*pi*(0:m-1)'/(n-1)));
    a0 = 0.5;
    a1 = 0.5;
    a2 = 0;
    a3 = 0;
    a4 = 0;
    break;
  case cw_hamming:
    //% Hamming window
    //%    w = (54 - 46*cos(2*pi*(0:m-1)'/(n-1)))/100;
    a0 = 0.54;
    a1 = 0.46;
    a2 = 0;
    a3 = 0;
    a4 = 0;
    break;
  case cw_blackman:
    //% Blackman window
    //%    w = (42 - 50*cos(2*pi*(0:m-1)/(n-1)) + 8*cos(4*pi*(0:m-1)/(n-1)))'/100;
    a0 = 0.42;
    a1 = 0.5;
    a2 = 0.08;
    a3 = 0;
    a4 = 0;
    break;
  case cw_flattopwin:
    //% Flattop window
    //% Coefficients as defined in the reference [1] (see flattopwin.m)
    a0 = 0.21557895;
    a1 = 0.41663158;
    a2 = 0.277263158;
    a3 = 0.083578947;
    a4 = 0.006947368;
    break;
  default:
    ASSERT(0);
    break;
  }
  for (i = 0; i < m; ++i) {
    double x = i * 1. / (n - 1);
    w[i] = a0 - a1 * cos(2 * CC_PI * x) + a2 * cos(4 * CC_PI * x) - a3 * cos(6 * CC_PI * x) + a4 * cos(8 * CC_PI * x);
  }
  return 0;
}
int gencoswin(int n, int window, double* w)
{
  int i, half = (n + 1) / 2;
  calc_window(half, n, window, w);
  for (i = 0; i < half; ++i) {
    w[n - 1 - i] = w[i];
  }
  return 0;
}

