
int canny(const img_t* im, double sigma, double scaling, double vert, double horz, img_t* gradient, img_t* or)
{
  int ii, jj, row_gaussian, col_gaussian, row, col;//, ceil_row, floor_row, ceil_col, floor_col;
  double xscaling = vert, yscaling = horz;
  img_t im1[1] = {0}, im2[1] = {0};
  double* gaussian;
  double gaussian1[] = {//
    1.96519161240319e-05, 0.000239409349497270, 0.00107295826497866, 0.00176900911404382, 0.00107295826497866, 0.000239409349497270, 1.96519161240319e-05,
    0.000239409349497270, 0.002916602954386440, 0.01307130758318940, 0.02155094284826830, 0.01307130758318940, 0.002916602954386440, 0.000239409349497270,
    0.001072958264978660, 0.013071307583189400, 0.05858153633060700, 0.09658462501856410, 0.05858153633060700, 0.013071307583189400, 0.001072958264978660,
    0.001769009114043820, 0.021550942848268300, 0.09658462501856410, 0.15924112569070200, 0.09658462501856410, 0.021550942848268300, 0.001769009114043820,
    0.001072958264978660, 0.013071307583189400, 0.05858153633060700, 0.09658462501856410, 0.05858153633060700, 0.013071307583189400, 0.001072958264978660,
    0.000239409349497270, 0.002916602954386440, 0.01307130758318940, 0.02155094284826830, 0.01307130758318940, 0.002916602954386440, 0.000239409349497270,
    1.96519161240319e-05, 0.000239409349497270, 0.00107295826497866, 0.00176900911404382, 0.00107295826497866, 0.000239409349497270, 1.96519161240319e-05
  };
  double gaussian2[] = {//
    4.92039284956766e-06, 1.94605312269499e-05, 5.99426561741466e-05, 0.000143794956950925, 0.000268644347022705, 0.000390875218503749, 0.000442919649189681, 0.000390875218503749, 0.000268644347022705, 0.000143794956950925, 5.99426561741466e-05, 1.94605312269499e-05, 4.92039284956766e-06,
    1.94605312269499e-05, 7.69678940713786e-05, 0.000237077804144399, 0.000568720087109968, 0.001062509003653700, 0.001545941478270670, 0.001751781194634260, 0.00154594147827067, 0.00106250900365370, 0.000568720087109968, 0.000237077804144399, 7.69678940713786e-05, 1.94605312269499e-05,
    5.99426561741466e-05, 0.000237077804144399, 0.000730251046830066, 0.001751781194634260, 0.003272758135181240, 0.004761834988810570, 0.005395865951330190, 0.00476183498881057, 0.00327275813518124, 0.00175178119463426, 0.000730251046830066, 0.000237077804144399, 5.99426561741466e-05,
    0.000143794956950925, 0.000568720087109968, 0.001751781194634260, 0.004202304628244280, 0.007850938633616100, 0.011423048308605800, 0.012944009520204300, 0.0114230483086058,  0.00785093863361610, 0.00420230462824428, 0.00175178119463426, 0.000568720087109968, 0.000143794956950925,
    0.000268644347022705, 0.001062509003653700, 0.003272758135181240, 0.007850938633616100, 0.014667484364301700, 0.021341063824105700, 0.024182593459085800, 0.0213410638241057,  0.0146674843643017,  0.00785093863361610, 0.00327275813518124, 0.00106250900365370, 0.000268644347022705,
    0.000390875218503749, 0.001545941478270670, 0.004761834988810570, 0.011423048308605800, 0.021341063824105700, 0.031051064642892900, 0.035185465866172100, 0.0310510646428929,  0.0213410638241057,  0.0114230483086058,  0.00476183498881057, 0.00154594147827067, 0.000390875218503749,
    0.000442919649189681, 0.001751781194634260, 0.005395865951330190, 0.012944009520204300, 0.024182593459085800, 0.035185465866172100, 0.039870356216688600, 0.0351854658661721,  0.0241825934590858,  0.0129440095202043,  0.00539586595133019, 0.00175178119463426, 0.000442919649189681,
    0.000390875218503749, 0.001545941478270670, 0.004761834988810570, 0.011423048308605800, 0.021341063824105700, 0.031051064642892900, 0.035185465866172100, 0.0310510646428929,  0.0213410638241057,  0.0114230483086058,  0.00476183498881057, 0.00154594147827067, 0.000390875218503749,
    0.000268644347022705, 0.001062509003653700, 0.003272758135181240, 0.007850938633616100, 0.014667484364301700, 0.021341063824105700, 0.024182593459085800, 0.0213410638241057,  0.0146674843643017,  0.00785093863361610, 0.00327275813518124, 0.00106250900365370, 0.000268644347022705,
    0.000143794956950925, 0.000568720087109968, 0.001751781194634260, 0.004202304628244280, 0.007850938633616100, 0.011423048308605800, 0.012944009520204300, 0.0114230483086058,  0.00785093863361610, 0.00420230462824428, 0.00175178119463426, 0.000568720087109968, 0.000143794956950925,
    5.99426561741466e-05, 0.000237077804144399, 0.000730251046830066, 0.001751781194634260, 0.003272758135181240, 0.004761834988810570, 0.005395865951330190, 0.00476183498881057, 0.00327275813518124, 0.00175178119463426, 0.000730251046830066, 0.000237077804144399, 5.99426561741466e-05,
    1.94605312269499e-05, 7.69678940713786e-05, 0.000237077804144399, 0.000568720087109968, 0.001062509003653700, 0.001545941478270670, 0.001751781194634260, 0.00154594147827067, 0.00106250900365370, 0.000568720087109968, 0.000237077804144399, 7.69678940713786e-05, 1.94605312269499e-05,
    4.92039284956766e-06, 1.94605312269499e-05, 5.99426561741466e-05, 0.000143794956950925, 0.000268644347022705, 0.000390875218503749, 0.000442919649189681, 0.000390875218503749, 0.000268644347022705, 0.000143794956950925, 5.99426561741466e-05, 1.94605312269499e-05, 4.92039284956766e-06,
  };

  if (sigma == 1) {
    gaussian = gaussian1;
    row_gaussian = col_gaussian = 7;
  }
  else if (sigma == 2) {
    gaussian = gaussian2;
    row_gaussian = col_gaussian = 13;
  }
  else {
    ASSERT(0 && "sigma");
  }

  //imwrite3(im);
  row = im->h, col = im->w;
  imsetsize(im1, row, col, sizeof(double), 1);

  //ceil_row = (int)ceil(row_gaussian / 2.);   // 与ceil_rol 相等
  //floor_row = (int)floor(row_gaussian / 2.); // 与floor_col相等
  //ceil_col = (int)ceil(col_gaussian / 2.);   // 与ceil_rol 相等
  //floor_col = (int)floor(col_gaussian / 2.); // 与floor_col相等
  //{utime_start(_start_time);
#if 0

  for (ii = ceil_row; ii <= row - floor_row; ++ii) {
    for (jj = ceil_col; jj <= col - floor_col ; ++jj) {
      uchar* pos = im->tt.data + im->w * (ii - floor_row - 1) + (jj - floor_col - 1);
      double aaa = 0;
      DOT_PRODUCT2D(row_gaussian, col_gaussian, pos, im->w, 1, gaussian, col_gaussian, 1, aaa);
      //if (aaa>10)
      im1->tt.f8[im1->w * (ii - 1) + jj - 1] = (aaa);
    }
  }

#else
  Imfilter_f64(row, col, im->tt.data, im->s, row_gaussian, col_gaussian, gaussian, (double*)im1->tt.data, im1->w);
#endif
  //printf(" %.4f", utime_elapsed(_start_time));}
  //FPRINT1D("im1.txt", "%f\r\n", im1->w, (im1->tt.f8+im1->w*57), 1);
  imclone(im1, im2);
  //imshow(im2);  cvWaitKey(-1);
  imsetsize(gradient, row, col, sizeof(double), 1);
  imsetsize( or , row, col, sizeof(double), 1);

  //h =[-1 0 1] v =[-1;0;1]
  //   [-1 0 0]    [ 0 0 1]
  //d1=[ 0 0 0] d2=[ 0 0 0]
  //   [ 0 0 1]    [-1 0 0]
  ii = 0;

  for (jj = 1; jj < col - 1 ; ++jj) {
    double h, v, d1, d2, grad, vor, X, Y;
    int im2l = im2->w;
    double* pos = ((double*)im2->tt.data) + im2->w * ii + jj;
    h = pos[1] - 0;
    v = pos[im2l] - 0;
    d1 = pos[im2l + 1] - 0;
    d2 = 0 - pos[im2l - 1];
    X = (h + (d1 + d2) / 2.0) * xscaling;
    Y = (v + (d1 - d2) / 2.0) * yscaling;

    grad = sqrt(X * X + Y * Y);
    vor = atan2(-Y, X);            // Angles -PI to + PI.
    // Map angles to 0-PI.
    vor = vor < 0 ? (vor + PI) : vor;
    vor = vor * 180 / PI;            // Convert to degrees.
    ((double*)gradient->tt.data)[gradient->w * ii + jj] = grad;
    ((double*) or ->tt.data)[ or ->w * ii + jj] = vor;
  }

  for (ii = 1; ii < row - 1; ++ii) {
    for (jj = 1; jj < col - 1 ; ++jj) {
      double h, v, d1, d2, grad, vor, X, Y;
      int im2l = im2->w;
      double* pos = ((double*)im2->tt.data) + im2->w * ii + jj;
      h = pos[1] - pos[-1];
      v = pos[im2l] - pos[-im2l];
      d1 = pos[im2l + 1] - pos[-im2l - 1];
      d2 = pos[-im2l + 1] - pos[im2l - 1];
      X = (h + (d1 + d2) / 2.0) * xscaling;
      Y = (v + (d1 - d2) / 2.0) * yscaling;

      grad = sqrt(X * X + Y * Y);
      vor = atan2(-Y, X);            // Angles -PI to + PI.
      // Map angles to 0-PI.
      vor = vor < 0 ? (vor + PI) : vor;
      vor = vor * 180 / PI;            // Convert to degrees.
      ((double*)gradient->tt.data)[gradient->w * ii + jj] = grad;
      ((double*) or ->tt.data)[ or ->w * ii + jj] = vor;
    }
  }

  //FPRINT1D("or.txt", "%f\r\n", or->w, (or->tt.f8+or->w*136), 1);
  imfree(im1);
  imfree(im2);
  return 0;
}
//#define error(xx) printf
int adjgamma(const img_t* im, double g, img_t* newim)
{
  int i, n = im->h * im->w, mi = 0, ma = 0;
  double mind, maxd;

  if (g <= 0) {
    printf("Gamma value must be > 0");
    return 0;
  }

  imclone(im, newim);
  mi = 0, ma = 0;
  MINMAX_ELEMENT(n, ((double*)im->tt.data), mi, ma);
  mind = ((double*)im->tt.data)[mi], maxd = ((double*)im->tt.data)[ma];

  // rescale range 0-1
  for (i = 0; i < n; ++i) {
    double x = ((double*)newim->tt.data)[i];
    x = pow((x - mind) / (maxd - mind), (1. / g)); // Apply gamma function
    ((double*)newim->tt.data)[i] = x;
  }

  return 0;
}
