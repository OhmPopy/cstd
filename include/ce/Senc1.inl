
#include <stdio.h>
#include <stdlib.h>

#include <xdc/std.h>
#include <ti/sdo/ce/Engine.h>
#include <ti/sdo/ce/speech1/sphenc1.h>
#include <ti/xdais/dm/ispeech1_pcm.h>

//#include <ti/sdo/dmai/Dmai.h>
//#include <ti/sdo/dmai/Buffer.h>
//#include <ti/sdo/dmai/ce/Senc1.h>

#define MODULE_NAME     "Senc1"

typedef struct Senc1_Object {
  SPHENC1_Handle      hEncode;
  Int32               minInBufSize;
  Int32               minOutBufSize;
} Senc1_Object;
Senc1_Object hSe1[1] = {0};

const SPHENC1_Params Senc1_Params_DEFAULT = {
  sizeof(SPHENC1_Params),
  160,
  ISPEECH1_PCM_COMPAND_ALAW,
  0,
  0,
  0,
  0,
  0,
  NULL,
};

const SPHENC1_DynamicParams Senc1_DynamicParams_DEFAULT = {
  sizeof(SPHENC1_DynamicParams),
  0,
  0,
  0,
  ISPEECH1_VADFLAG_DEFAULT,
  0,
  0,
  0,
  0,
  0,
};

/******************************************************************************
 * Senc1_process
 ******************************************************************************/
int Senc1_process(const unsigned char* src, int slen, unsigned char* dst, int dlen, int type)
{
  XDM1_SingleBufDesc      inBufDesc;
  XDM1_SingleBufDesc      outBufDesc;
  SPHENC1_InArgs          inArgs;
  SPHENC1_OutArgs         outArgs;
  XDAS_Int32              status;
  XDAS_Int8*              inPtr;
  XDAS_Int8*              outPtr;

  assert(hSe1);

  inPtr = (unsigned char*)(src);
  outPtr = (dst);

  inBufDesc.buf           = inPtr;
  inBufDesc.bufSize       = slen;

  outBufDesc.buf          = outPtr;
  outBufDesc.bufSize      = dlen;

  inArgs.size             = sizeof(SPHENC1_InArgs);
  outArgs.size            = sizeof(SPHENC1_OutArgs);

  /* We never use the inArgs.data fields, so initialize them to NULL. */
  inArgs.data.buf = (XDAS_Int8*) NULL;
  inArgs.data.bufSize = 0L;

  /* Encode the speech buffer */
  status = SPHENC1_process(hSe1->hEncode, &inBufDesc, &outBufDesc, &inArgs, &outArgs);

  //DBG("SPHENC1_process() ret %d \n", status);

  if (status != SPHENC1_EOK) {
    DBG("SPHENC1_process() failed with error (%d ext: 0x%x)\n",
        (Int)status, (Uns)outArgs.extendedError);
    return Dmai_EFAIL;
  }

  /* Encoded Bytes Generated: assume output buffer was filled  */

  /* IMPORTANT NOTE:                                           */
  /* This implementation assumes that for every frame the      */
  /* number of bytes generated by the encoder is EQUAL to the  */
  /* size of the output buffer requested by the codec.         */
  //Buffer_setNumBytesUsed(hOutBuf, Senc1_getOutBufSize(hSe1));
  
  dlen = hSe1->minOutBufSize;
  return dlen;
}

/******************************************************************************
 * Senc1_create
 ******************************************************************************/
int Senc1_create()
{
  Char* codecName = "g711enc";
  SPHENC1_Params* params = &Senc1_Params_DEFAULT;
  SPHENC1_DynamicParams* dynParams = &Senc1_DynamicParams_DEFAULT;
  SPHENC1_Status      encStatus;
  XDAS_Int32          status;
  SPHENC1_Handle      hEncode;

  if (hEngine == NULL || codecName == NULL ||
      params == NULL || dynParams == NULL) {
    DBG("Cannot pass null for engine, codec name, params or dynamic params\n");
    return NULL;
  }

  /* Create speech encoder */
  hEncode = SPHENC1_create(hEngine, codecName, params);

  if (hEncode == NULL) {
    Dmai_err0("Can't open speech encode algorithm\n");
    return NULL;
  }

  DBG("Setting dynParams \n");

  /* Set dynamic parameters */
  encStatus.size = sizeof(SPHENC1_Status);
  encStatus.data.buf = NULL;
  status = SPHENC1_control(hEncode, XDM_SETPARAMS, dynParams, &encStatus);

  if (status != SPHENC1_EOK) {
    DBG("XDM_SETPARAMS failed, status=%d\n", status);
    SPHENC1_delete(hEncode);
    return NULL;
  }

  DBG("Made XDM_SETPARAMS control call\n");

  /* Get buffer requirements */
  status = SPHENC1_control(hEncode, XDM_GETBUFINFO, dynParams, &encStatus);

  if (status != SPHENC1_EOK) {
    DBG("XDM_GETBUFINFO failed, status=%d\n", status);
    SPHENC1_delete(hEncode);
    return NULL;
  }

  hSe1->minInBufSize = encStatus.bufInfo.minInBufSize[0];
  hSe1->minOutBufSize = encStatus.bufInfo.minOutBufSize[0];

  DBG("Speech encoder requires min buffer sizes in %u and out %u\n",
      (Uns) encStatus.bufInfo.minInBufSize[0],
      (Uns) encStatus.bufInfo.minOutBufSize[0]);

  hSe1->hEncode = hEncode;

  return 0;
}

/******************************************************************************
 * Senc1_delete
 ******************************************************************************/
int Senc1_delete()
{
  if (hSe1) {
    if (hSe1->hEncode) {
      SPHENC1_delete(hSe1->hEncode);
    }

  }

  return Dmai_EOK;
}

/******************************************************************************
 * Senc1_getVisaHandle
 ******************************************************************************/
SPHENC1_Handle Senc1_getVisaHandle()
{
  assert(hSe1);

  return hSe1->hEncode;
}

/******************************************************************************
 * Senc1_getInBufSize
 ******************************************************************************/
Int32 Senc1_getInBufSize()
{
  assert(hSe1);

  return hSe1->minInBufSize;
}

/******************************************************************************
 * Senc1_getOutBufSize
 ******************************************************************************/
Int32 Senc1_getOutBufSize()
{
  assert(hSe1);

  return hSe1->minOutBufSize;
}
