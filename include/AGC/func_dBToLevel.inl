// =========================================================================
//
//              幅度值到dB值的转化
//
// =========================================================================
//
//　(C) 2003-2010 广州海格通信集团股份有限公司
//   作  者：   王 云 飞
//   版  本：    V 1.0
//   创建日期： 2010年1月25日
//   完成日期： 2010年1月25日
//--------------------------------------------------------------------------
//  功能说明：
//    1. 输入参数　　　　dB : dB值，Q6格式　　dB*2.^6
//    2. 输出参数　　　　level_out :  电平幅度, Q6格式　10.^(dB/20/2.^6)*2.^6;
//    3. 输出level_out的范围[0,32767],对应dB的最大值20*log10(32767/64) = 54dB, 则对应输入的ｄＢ的范围[0,54*64]
//    4. 查找表Table, 用于计算小数部分； dB数 = a*6.02 + 余数
//    5. 6.02*2.^6 = 385, 需要9bit存储 ， 取高7位作为相对地址查表， 低两位四舍五入(round)截断 ;
//      由于输入的dB值以Q6格式表示，所以总的量化分辨率为1/2.^(6-2) = 1/16dB
//    6.表长度：[0,385/4+ 1], 所以表长为98,
//      表内容： dB余数对应的level值， 表内容 = 10.^((相对地址×4/64)/20)*64
//      例如： 相对地址 = 80; dB余数= 80*4/64 = 5dB, 表内容＝ 10.^(5/20)*64 = 114;
//    7: 输出放大倍数 ＝ 表内容×2.^a;
//--------------------------------------------------------------------------
int func_dBToLevel(const double* dB, int len, double* level_out) {
  // 将对数幅度转化为电平幅度
  int table[] = { 64,64,65,65,66,66,67,67,68,68,69,69,70,70,71,71,72,72,73,73,74,74,75,76,76,77,77,78,78,79,79,80,81,81,82,82,83,84,84,85,85,86,87,87,88,88,89,90,90,91,92,92,93,94,94,95,96,96,97,98,99,99,100,101,101,102,103,104,104,105,106,107,107,108,109,110,111,111,112,113,114,115,115,116,117,118,119,120,121,121,122,123,124,125,126,127,128,129};
  //len = length( dB);
  double dB2Q = 385;       // 20*log10(2)*2.^6
  int ii;
  for (ii  = 0; ii<len; ++ii) {
    int dB_main = (int)floor(dB[(ii)]/dB2Q);               // 整数部分
    double dB_res = fmod(dB[(ii)],dB2Q);                  // 小数部分
    int dB_res_Addr = (int)floor(( dB_res + 2)/(2*2));    // round量化格式
    // 查表
    int level_res = table[(dB_res_Addr)];
    level_out[(ii)] = level_res * (1 << dB_main);
  }
  return 0;
}