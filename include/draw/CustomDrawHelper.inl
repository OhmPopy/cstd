

// CCustomDrawHelper

CCustomDrawHelper()
  : m_bWndHasFocus(FALSE)
  , m_bFocusItem(FALSE)
  , m_bSelected(FALSE)
  , m_bIsHotItem(FALSE)
  , m_bIsPressed(FALSE)
  , m_bWndEnabled(TRUE)
  , m_bDrawBorderWhenFill(TRUE)
{
  m_rcBounds = iRECT(0, 0, 0, 0);
}

//  Different cases with different colors:
//  wnd has focus                           wnd has no focus
//  +-------------------------------+    +--------------------------+
//  selected           unselected           selected      unselected
//  +---------------+  +------------+    +-------------+  +---------+
//  hot  not hot        hot not hot        hot not hot    hot not hot
//   1  +--------+  3  x  1  4  3  x
//   focus no focus
//   1 2


// TODO: The colors can be generated by some kind of algorithm so that the the caller can control the main color.
// e.g. With given color (like sky-blue), all the other colors can be generated by reducing/increasing its luminosity,
// so RGB2HSL and HSL2RGB will be needed in that case. However, the difficult part is how to design the rule, which I
// do not have time by now, so I just use hard coded value here.
int DrawItemBackground(HDDC hDC, RECT rect, BYTE byAlpha /*= 255*/)
{
  if (ShouldFillBackground()) {
    COLORREF clrFillColor1;
    COLORREF clrFillColor2;

    if (m_bSelected) {
      if (m_bIsHotItem || (m_bFocusItem && m_bWndHasFocus)) {
        clrFillColor1 = RGB_ITEM_SELFOCUS_FILL_COLOR1;
        clrFillColor2 = RGB_ITEM_SELFOCUS_FILL_COLOR2;
      }
      else if (m_bWndHasFocus) {
        ASSERT(!m_bFocusItem);
        clrFillColor1 = RGB_ITEM_SELECTED_FILL_COLOR1;
        clrFillColor2 = RGB_ITEM_SELECTED_FILL_COLOR2;
      }
      else {
        clrFillColor1 = RGB_ITEM_SELNOFOCUS_FILL_COLOR1;
        clrFillColor2 = RGB_ITEM_SELNOFOCUS_FILL_COLOR2;
      }
    }
    else {
      // not selected, hot item
      clrFillColor1 = RGB_ITEM_HOT_FILL_COLOR1;
      clrFillColor2 = RGB_ITEM_HOT_FILL_COLOR2;
    }

    if (m_bDrawBorderWhenFill) {
      COLORREF clrInnerBorder;
      COLORREF clrOuterBorder;

      if (m_bSelected) {
        clrInnerBorder = (m_bWndHasFocus || m_bIsHotItem) ? RGB_ITEM_SELFOCUS_INNER_BORDER_COLOR : RGB_ITEM_SELNOFOCUS_INNER_BORDER_COLOR;
        clrOuterBorder = (m_bWndHasFocus || m_bIsHotItem) ? RGB_ITEM_SELFOCUS_OUTER_BORDER_COLOR : RGB_ITEM_SELNOFOCUS_OUTER_BORDER_COLOR;
      }
      else {
        clrInnerBorder = RGB_ITEM_HOT_INNER_BORDER_COLOR;
        clrOuterBorder = RGB_ITEM_HOT_OUTER_BORDER_COLOR;
      }

      DrawRoundRectItem(hDC, rect, clrFillColor1, clrFillColor2, clrInnerBorder, clrOuterBorder, byAlpha);
    }
    else {
      DeflateRect(&rect, 2, 2);
      FillGradient(hDC, rect, clrFillColor1, clrFillColor2, GFT_TOP_BOTTOM, byAlpha);
    }

    //TRACE("====> hilight %d %d [%d, %d]\n", nItem, nSubItem, rect.left, rect.right);
  }
  else if (m_bFocusItem) {
    RECT rcItem = IsRectEmpty(&m_rcBounds) ? rect : m_rcBounds;
    DrawFocus(hDC, rcItem, byAlpha);
  }

  return 0;
}

int DrawFocus(HDDC hDC, RECT rect, BYTE byAlpha /*= 255*/)
{
  ASSERT(!ShouldFillBackground() && m_bFocusItem);
  DrawSimpleRoundRectBorder(hDC, rect, RGB_ITEM_SELFOCUS_OUTER_BORDER_COLOR, FALSE);
  return 0;
}

int DrawThemeBackground(HDDC hDC, RECT rect, CDTBT type)
{
  CDSTATEID state;

  if (!m_bWndEnabled) {
    state = CDSTATEID_DISABLED;
  }
  else if (m_bIsPressed) {
    state = CDSTATEID_PRESSED;
  }
  else if (m_bIsHotItem) {
    state = CDSTATEID_HOT;
  }
  else {
    state = CDSTATEID_NORMAL;
  }

  CustomDrawThemeBackground(hDC, type, state, rect);
  return 0;
}
