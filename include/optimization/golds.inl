
#include <math.h>
typedef double (fun_dd_t)(double x);

int golds(fun_dd_t phi,double a, double b, double delta,double epsilon, double* s, double* phis, double* G, double* E) {
  double t, h, p, q, phia, phib, phip, phiq, ds, dphi;
  //功能: 0.618法精确线搜索
  //输入: phi是目标函数, a, b 是搜索区间的两个端点
  //         delta, epsilon分别是自变量和函数值的容许误差
  //输出:  s, phis分别是近似极小点和极小值,  G是nx4矩阵,
  //         其第k行分别是a,p,q,b的第k次迭代值[ak,pk,qk,bk],
  //          E=[ds,dphi], 分别是s和phis的误差限.
  int k = 0;
  t=(sqrt(5)-1)/2;  h=b-a;  phia=phi(a); phib=phi(b);
  p=a+(1-t)*h;  q=a+t*h; phip=phi(p); phiq=phi(q);
  if (G) {
    *G++ = a, *G++ = p, *G++ = q, *G++ = b;
  }
  while ((fabs(phib-phia)>epsilon)||(h>delta)) {
    if(phip<phiq) {
      b=q;  phib=phiq; q=p; phiq=phip;
      h=b-a; p=a+(1-t)*h;  phip=phi(p);
    } else {
      a=p; phia=phip;  p=q; phip=phiq;
      h=b-a;  q=a+t*h;  phiq=phi(q);
    }
    k=k+1;
    if (G) {
      *G++ = a, *G++ = p, *G++ = q, *G++ = b;
    }
  }
  ds=fabs(b-a); dphi=fabs(phib-phia);
  if(phip<=phiq) {
    *s=p;  *phis=phip;
  } else {
    *s=q;  *phis=phiq;
  }
  if (E) {
    *E++=ds, *E++=dphi;
  }
  return k;
}
